title: Go语言知识点和踩坑总结
date: 2015-11-12 15:00:19
tags: Golang
---

## 安装方式（OSX）
1、安装Xcode，需要内置GCC编译Golang中Go和C语言的联合开发模块（Go1.5版本已经实现全面Go语言开发）
2、Mac下直接通过Homebrew--->brew install go<!--more-->
- 安装完毕后brew安装路径目录如图所示：
![image](/images/go1.png)

## 工作区间结构
![image](/images/go2.png)
> Golang的工作空间必须包含以上三个文件夹，在本地的安装目录中也出现了这三类文件夹
>
> 当然你也已选择不配置，直接在系统安装目录下进行开发，不过这肯定是极不推荐的方式，我们必须得另建工作环境
>
> 首先我们得选择一个目录，建立上述三个同名称的文件夹，然后在终端的配置文件中进行如下配置(我的是在.zshrc中)

---------
> export GOPATH=/Users/Makcy/HXF/project_go
> export GOROOT=/usr/local/Cellar/go/1.4.2/libexec
> export PATH=\$PATH:\$GOPATH/bin

**下面介绍这三个文件夹的功能和作用**
**src---> 存放源码文件**

**pkg---> 存放编译好的包文件，通过`go install`产生.a结尾的包文件(注意：想要产生包文件，所编译的.go文件中必须不能包含main方法，否则会自动执行`go build`命令，直接在bin目录下生成可执行文件)**

**bin---> 通过go build命令在该目录下能生成一个可执行文件**


-------
## 代码结构
``` go
package main

import(
	"fmt"
	"log"
)
func main() {
	fmt.Println("Hello World")
	log.Println("Hello Golang")
}
```
**需要注意如下概念**
> **1、顶部声明包名（必须，可自定义）**
> **2、import中导入所需要的包 **
> **3、pacgeage main 中必须包含一个main函数，也就是所谓的入口函数**
> **4、只有包含main 函数的 main包文件 才能够通过 `go run xxx.go` 方法执行**
> **5、倘若有很多.go文件属于main包，那么需要同时执行所有.go文件，执行命令`go run  *.go`**

## 第三方包管理
> **通过`go get` 包名`命令，可以直接获取远程第三方源码，并自动执行 `go install` 命令，在pkg文件夹下生产相应地包**

> **不过有些package下载源可能出现了问题（比如google的websocket)，那么可以去“golang中国”里寻找**


## Go的优势
>**部署方便—>**GO是一个强类型静态语言，可以把代码编译为本地机器指令。它的RUNTIME是会在编译时一起链接到执行文件中，这也就意味着我们不需要像JAVA那样装一个JVM。而且编译出的执行文件本身不依赖于其他动态库，完全可以做到轻松的发布。当然，如果你用GO编写了调用一些动态库接口的代码，那么还是需要根据实际情况来部署这个动态库.
>
> **特性少，语法简单—>**GO是崇尚极简主义,GO的特性很少，很多GO的使用者都反馈，GO的关键字至少完全可以记在大脑里。同时它的语法极为简单，而且语义清晰.
>
> **内建的并发原语—>**廉价的goroutine可以让我们欢快的处理异步任务，channel可以用来交换数据。借助goroutine，可以很容易的实现高性能的服务端。

------
## 并发机制
> **goroutine是Go并行设计的核心。**goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。
>
> **goroutine是通过Go的runtime管理的一个线程管理器。goroutine通过go关键字实现了，其实就是一个普通的函数.**
>
>`并且能实现cpu的调度，自由使用cpu核数量`

------
## 线程间的通信--Channel
>**1、channel可以与Unix shell 中的双向管道做类比：**可以通过它发送或者接收值。这些值只能是特定的类型：channel类型。定义一个channel时，也需要定义发送到channel的值的类型
>
>**2、默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得Goroutines同步变的更加的简单，而不需要显式的lock。**所谓`阻塞`，也就是如果读取（value := <-ch）它将会被阻塞，直到有数据接收。其次，任何发送（ch<-5）将会被阻塞，直到数据被读出。无缓冲channel是在多个goroutine之间同步很棒的工具。
>
>**3、**如果同时有多个Channel，可以通过select 关键字进行自动选择未阻塞的Channel 来进行相关的操作

------

## Struct与interface类型
>**1、**在Go中没有Class 关键字，但是通过Struct结构实现了Class 的功能。
>**2、**如果需要实现继承，只需要进行Struct的嵌套
>**3、**interface就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实现，其实本质还是接口，只是写法不同并且添加了新用法罢了
>**4、**空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。
>**5、**如若想取得空interface中的值，可通过断言语句来进行依次判断

------

## Go独有特性
>**1、**函数能有多个返回值，且调用时可用“_”下划线占位，进行忽略只接收想要的返回值
>**2、**原生支持UTF-8编码
>**3、**函数中defer关键字能，在函数执行完毕之后，进行调用，类似于析构函数
>**4、**可用For 语句配合 range + 集合类型，来进行遍历
>**5、**if条件语句中可使用赋值语句
>**6、**函数中的参数，允许指针传递
>**7、**go项目的main包中必须有main函数.每个package中默认有一个Init初始化函数，可自定义多个init函数，但是业界规范最好是只用一个

------
## Go一些值得注意的小细节
>**1、**声明的变量和包必须使用到，不然编译报错
>**2、**变量声明 和 函数声明 位置 与市面流行语言相反
>**3、**：=是定义，=是赋值，_表示忽略
>**4、**大写字母开头的函数，默认为Public
>**5、**小写字母开头的函数，默认为Private

------
## 一些基于Go的Web框架
>**web.go**
>**Revel**，类似Java的play框架
>**Macaron**
>**goku**，类似asp.net
>**beego**，类似python的tornado和php的ci
`其中最后三个是由国人开发的哦~`
